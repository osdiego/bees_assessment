<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sbees.secure API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sbees.secure</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Callable, Sequence

import pandas as pd
import pycountry


def concat_dataframes(
    df1: pd.DataFrame,
    df2: pd.DataFrame,
    rename_cols: dict[str, str] = None,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a concatenated DataFrame from the provide DataFrames. It also
        renames the columns of the first df according to the provided dictionary

    Args:
        df1 (pd.DataFrame): the DataFrame which columns will be renamed
        df2 (pd.DataFrame): the DataFrame which column names will be preserved
        rename_cols (dict[str, str], optional): a dictionary structured as
            {&#39;column_to_be_renamed&#39;: &#39;new_column_name&#39;}. Defaults to None.

    Returns:
        pd.DataFrame: the concatenated DataFrame, with the column names of the
            second DataFrame
    &#39;&#39;&#39;

    df1_renamed = df1.rename(columns=rename_cols) if rename_cols else df1
    df_concatenated = pd.concat([df1_renamed, df2])

    return df_concatenated


def clean_columns_values(
    df: pd.DataFrame,
    columns: list[str],
    operation: Callable = str.capitalize,
    replaces: dict[str, dict[str, str]] = None,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the original DataFrame, performing the operation on the
        specified columns, besides replacing a set of specified words in each
        column

    Args:
        df (pd.DataFrame): the base DataFrame
        columns (list[str]): the list of columns to be fixed
        operation (Callable, optional): the operation to be performed in each
            column. Defaults to str.capitalize.
        replaces (dict[str, dict[str, str]], optional): the columns which to
            replace values (if any) and the values.

    Returns:
        pd.DataFrame: the cleaned DataFrame, with the column names of the second
            DataFrame

    &gt;&gt;&gt; replace_words = {&#39;colA&#39;: {&#39;Old&#39;: &#39;New&#39;}}
    &gt;&gt;&gt; clean_columns_values(df, [&#39;colA&#39;, &#39;colB], str.lower, replace_words)
    &#39;&#39;&#39;

    local_df = df.copy()
    for col in columns:
        local_df[col] = local_df[col].apply(operation)

        if replaces and col in replaces:
            words_to_replace = replaces[col]

            # &#34;w&#34; stands for &#34;word&#34;
            local_df[col] = local_df[col].apply(
                lambda w: words_to_replace[w] if w in words_to_replace else w)

    return local_df


def format_country(country: str, format: str = &#39;alpha_2&#39;) -&gt; str:
    &#39;&#39;&#39;Gives the proper name of a country according to a specific format

    Args:
        country (str): the string to search for. It can be any official value,
            e.g. GB / GBR / United Kingdom
        format (str): the desired output format for the country name (it needs
            to be a valid attribute of the pycountry object). Defaults to
            &#39;alpha_2&#39;.

    Returns:
        str: the country name properly formatted.
    &#39;&#39;&#39;

    # Strip the name so it don&#39;t brake during the interaction with pycountry
    country = country.strip()

    # Special cases that need treatment
    special_cases = {
        &#39;UK&#39;: &#39;GB&#39;
    }

    if country.upper() in special_cases:
        country = &#39;GB&#39;

    return getattr(pycountry.countries.lookup(country), format)


def fix_country_columns(
        df: pd.DataFrame,
        columns: list[str],
        format: str = &#39;alpha_2&#39;,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the original DataFrame, standardizing the country names
        on the provided columns with the format desired

    Args:
        df (pd.DataFrame): the base DataFrame
        columns (list[str]): the list of columns to be fixed
        format (str, optional): format (str): the desired output format for the
            country name (it needs to be a valid attribute of the pycountry
            object). Defaults to &#39;alpha_2&#39;.

    Returns:
        pd.DataFrame: the cleaned DataFrame
    &#39;&#39;&#39;

    local_df = df.copy()

    for col in columns:
        local_df[col] = local_df[col].apply(
            lambda country: format_country(country, format))

    return local_df


def merge_only_strings(array_of_values: Sequence, separator=&#39; / &#39;) -&gt; str:
    &#39;&#39;&#39;Returns a string from an array of values, concatenating only the
        non-empty unique strings (ignores also nan values)

    Args:
        array_of_values (Sequence): the array to filter and join
        separator (str, optional): the separator to use to join the values in
            case the cleaned array has more than 1 value. Defaults to &#39; / &#39;.

    Returns:
        str: the final string
    &#39;&#39;&#39;

    unique_non_null_values = {
        v for v in array_of_values if isinstance(v, str) and v.strip()}

    return separator.join(unique_non_null_values)


def merge_string_columns(
        df: pd.DataFrame,
        column_a: str,
        column_b: str,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, removing the duplicated column

    Args:
        df (pd.DataFrame): the original DataFrame
        column_a (str): the name of the column to preserve
        column_b (str): the name of the column to be deleted

    Returns:
        pd.DataFrame: the final DataFrame, with just column_a, but with the
            values from both columns merged
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column_a] = df[[column_a, column_b]].apply(
        merge_only_strings, axis=1)

    local_df.drop([column_b], axis=1, inplace=True)

    return local_df


def clean_dict_column(df: pd.DataFrame, column: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, cleaning the string column
    formatted as dict, getting only the value of the first key of the dict.
    Works only if the value of the key is a list.

    By avoid using eval(), this method is secure, but for that it was assumed
    that the structure of the strings will always be the same:
    a dictionary with only 1 key and the value always a list.

    Args:
        df (pd.DataFrame): the original DataFrame
        column (str): the column name

    Returns:
        pd.DataFrame: the cleaned DataFrame
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column] = local_df[column].apply(
        lambda s: s[s.find(&#39;[&#39;):s.find(&#39;]&#39;)+1])

    return local_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sbees.secure.clean_columns_values"><code class="name flex">
<span>def <span class="ident">clean_columns_values</span></span>(<span>df: pandas.core.frame.DataFrame, columns: list, operation: Callable = &lt;method &#x27;capitalize&#x27; of &#x27;str&#x27; objects&gt;, replaces: dict = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the original DataFrame, performing the operation on the
specified columns, besides replacing a set of specified words in each
column</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the base DataFrame</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>the list of columns to be fixed</dd>
<dt><strong><code>operation</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>the operation to be performed in each
column. Defaults to str.capitalize.</dd>
<dt><strong><code>replaces</code></strong> :&ensp;<code>dict[str, dict[str, str]]</code>, optional</dt>
<dd>the columns which to
replace values (if any) and the values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the cleaned DataFrame, with the column names of the second
DataFrame</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; replace_words = {'colA': {'Old': 'New'}}
&gt;&gt;&gt; clean_columns_values(df, ['colA', 'colB], str.lower, replace_words)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_columns_values(
    df: pd.DataFrame,
    columns: list[str],
    operation: Callable = str.capitalize,
    replaces: dict[str, dict[str, str]] = None,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the original DataFrame, performing the operation on the
        specified columns, besides replacing a set of specified words in each
        column

    Args:
        df (pd.DataFrame): the base DataFrame
        columns (list[str]): the list of columns to be fixed
        operation (Callable, optional): the operation to be performed in each
            column. Defaults to str.capitalize.
        replaces (dict[str, dict[str, str]], optional): the columns which to
            replace values (if any) and the values.

    Returns:
        pd.DataFrame: the cleaned DataFrame, with the column names of the second
            DataFrame

    &gt;&gt;&gt; replace_words = {&#39;colA&#39;: {&#39;Old&#39;: &#39;New&#39;}}
    &gt;&gt;&gt; clean_columns_values(df, [&#39;colA&#39;, &#39;colB], str.lower, replace_words)
    &#39;&#39;&#39;

    local_df = df.copy()
    for col in columns:
        local_df[col] = local_df[col].apply(operation)

        if replaces and col in replaces:
            words_to_replace = replaces[col]

            # &#34;w&#34; stands for &#34;word&#34;
            local_df[col] = local_df[col].apply(
                lambda w: words_to_replace[w] if w in words_to_replace else w)

    return local_df</code></pre>
</details>
</dd>
<dt id="sbees.secure.clean_dict_column"><code class="name flex">
<span>def <span class="ident">clean_dict_column</span></span>(<span>df: pandas.core.frame.DataFrame, column: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the provided DataFrame, cleaning the string column
formatted as dict, getting only the value of the first key of the dict.
Works only if the value of the key is a list.</p>
<p>By avoid using eval(), this method is secure, but for that it was assumed
that the structure of the strings will always be the same:
a dictionary with only 1 key and the value always a list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the original DataFrame</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>the column name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the cleaned DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_dict_column(df: pd.DataFrame, column: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, cleaning the string column
    formatted as dict, getting only the value of the first key of the dict.
    Works only if the value of the key is a list.

    By avoid using eval(), this method is secure, but for that it was assumed
    that the structure of the strings will always be the same:
    a dictionary with only 1 key and the value always a list.

    Args:
        df (pd.DataFrame): the original DataFrame
        column (str): the column name

    Returns:
        pd.DataFrame: the cleaned DataFrame
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column] = local_df[column].apply(
        lambda s: s[s.find(&#39;[&#39;):s.find(&#39;]&#39;)+1])

    return local_df</code></pre>
</details>
</dd>
<dt id="sbees.secure.concat_dataframes"><code class="name flex">
<span>def <span class="ident">concat_dataframes</span></span>(<span>df1: pandas.core.frame.DataFrame, df2: pandas.core.frame.DataFrame, rename_cols: dict = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a concatenated DataFrame from the provide DataFrames. It also
renames the columns of the first df according to the provided dictionary</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df1</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the DataFrame which columns will be renamed</dd>
<dt><strong><code>df2</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the DataFrame which column names will be preserved</dd>
<dt><strong><code>rename_cols</code></strong> :&ensp;<code>dict[str, str]</code>, optional</dt>
<dd>a dictionary structured as
{'column_to_be_renamed': 'new_column_name'}. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the concatenated DataFrame, with the column names of the
second DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat_dataframes(
    df1: pd.DataFrame,
    df2: pd.DataFrame,
    rename_cols: dict[str, str] = None,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a concatenated DataFrame from the provide DataFrames. It also
        renames the columns of the first df according to the provided dictionary

    Args:
        df1 (pd.DataFrame): the DataFrame which columns will be renamed
        df2 (pd.DataFrame): the DataFrame which column names will be preserved
        rename_cols (dict[str, str], optional): a dictionary structured as
            {&#39;column_to_be_renamed&#39;: &#39;new_column_name&#39;}. Defaults to None.

    Returns:
        pd.DataFrame: the concatenated DataFrame, with the column names of the
            second DataFrame
    &#39;&#39;&#39;

    df1_renamed = df1.rename(columns=rename_cols) if rename_cols else df1
    df_concatenated = pd.concat([df1_renamed, df2])

    return df_concatenated</code></pre>
</details>
</dd>
<dt id="sbees.secure.fix_country_columns"><code class="name flex">
<span>def <span class="ident">fix_country_columns</span></span>(<span>df: pandas.core.frame.DataFrame, columns: list, format: str = 'alpha_2') ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the original DataFrame, standardizing the country names
on the provided columns with the format desired</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the base DataFrame</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>the list of columns to be fixed</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>format (str): the desired output format for the
country name (it needs to be a valid attribute of the pycountry
object). Defaults to 'alpha_2'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the cleaned DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fix_country_columns(
        df: pd.DataFrame,
        columns: list[str],
        format: str = &#39;alpha_2&#39;,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the original DataFrame, standardizing the country names
        on the provided columns with the format desired

    Args:
        df (pd.DataFrame): the base DataFrame
        columns (list[str]): the list of columns to be fixed
        format (str, optional): format (str): the desired output format for the
            country name (it needs to be a valid attribute of the pycountry
            object). Defaults to &#39;alpha_2&#39;.

    Returns:
        pd.DataFrame: the cleaned DataFrame
    &#39;&#39;&#39;

    local_df = df.copy()

    for col in columns:
        local_df[col] = local_df[col].apply(
            lambda country: format_country(country, format))

    return local_df</code></pre>
</details>
</dd>
<dt id="sbees.secure.format_country"><code class="name flex">
<span>def <span class="ident">format_country</span></span>(<span>country: str, format: str = 'alpha_2') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the proper name of a country according to a specific format</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>country</code></strong> :&ensp;<code>str</code></dt>
<dd>the string to search for. It can be any official value,
e.g. GB / GBR / United Kingdom</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>the desired output format for the country name (it needs
to be a valid attribute of the pycountry object). Defaults to
'alpha_2'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the country name properly formatted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_country(country: str, format: str = &#39;alpha_2&#39;) -&gt; str:
    &#39;&#39;&#39;Gives the proper name of a country according to a specific format

    Args:
        country (str): the string to search for. It can be any official value,
            e.g. GB / GBR / United Kingdom
        format (str): the desired output format for the country name (it needs
            to be a valid attribute of the pycountry object). Defaults to
            &#39;alpha_2&#39;.

    Returns:
        str: the country name properly formatted.
    &#39;&#39;&#39;

    # Strip the name so it don&#39;t brake during the interaction with pycountry
    country = country.strip()

    # Special cases that need treatment
    special_cases = {
        &#39;UK&#39;: &#39;GB&#39;
    }

    if country.upper() in special_cases:
        country = &#39;GB&#39;

    return getattr(pycountry.countries.lookup(country), format)</code></pre>
</details>
</dd>
<dt id="sbees.secure.merge_only_strings"><code class="name flex">
<span>def <span class="ident">merge_only_strings</span></span>(<span>array_of_values: Sequence, separator=' / ') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string from an array of values, concatenating only the
non-empty unique strings (ignores also nan values)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array_of_values</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>the array to filter and join</dd>
<dt><strong><code>separator</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the separator to use to join the values in
case the cleaned array has more than 1 value. Defaults to ' / '.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the final string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_only_strings(array_of_values: Sequence, separator=&#39; / &#39;) -&gt; str:
    &#39;&#39;&#39;Returns a string from an array of values, concatenating only the
        non-empty unique strings (ignores also nan values)

    Args:
        array_of_values (Sequence): the array to filter and join
        separator (str, optional): the separator to use to join the values in
            case the cleaned array has more than 1 value. Defaults to &#39; / &#39;.

    Returns:
        str: the final string
    &#39;&#39;&#39;

    unique_non_null_values = {
        v for v in array_of_values if isinstance(v, str) and v.strip()}

    return separator.join(unique_non_null_values)</code></pre>
</details>
</dd>
<dt id="sbees.secure.merge_string_columns"><code class="name flex">
<span>def <span class="ident">merge_string_columns</span></span>(<span>df: pandas.core.frame.DataFrame, column_a: str, column_b: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the provided DataFrame, removing the duplicated column</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the original DataFrame</dd>
<dt><strong><code>column_a</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the column to preserve</dd>
<dt><strong><code>column_b</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the column to be deleted</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the final DataFrame, with just column_a, but with the
values from both columns merged</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_string_columns(
        df: pd.DataFrame,
        column_a: str,
        column_b: str,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, removing the duplicated column

    Args:
        df (pd.DataFrame): the original DataFrame
        column_a (str): the name of the column to preserve
        column_b (str): the name of the column to be deleted

    Returns:
        pd.DataFrame: the final DataFrame, with just column_a, but with the
            values from both columns merged
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column_a] = df[[column_a, column_b]].apply(
        merge_only_strings, axis=1)

    local_df.drop([column_b], axis=1, inplace=True)

    return local_df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sbees" href="index.html">sbees</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sbees.secure.clean_columns_values" href="#sbees.secure.clean_columns_values">clean_columns_values</a></code></li>
<li><code><a title="sbees.secure.clean_dict_column" href="#sbees.secure.clean_dict_column">clean_dict_column</a></code></li>
<li><code><a title="sbees.secure.concat_dataframes" href="#sbees.secure.concat_dataframes">concat_dataframes</a></code></li>
<li><code><a title="sbees.secure.fix_country_columns" href="#sbees.secure.fix_country_columns">fix_country_columns</a></code></li>
<li><code><a title="sbees.secure.format_country" href="#sbees.secure.format_country">format_country</a></code></li>
<li><code><a title="sbees.secure.merge_only_strings" href="#sbees.secure.merge_only_strings">merge_only_strings</a></code></li>
<li><code><a title="sbees.secure.merge_string_columns" href="#sbees.secure.merge_string_columns">merge_string_columns</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>