<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sbees.insecure API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sbees.insecure</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from typing import Any

import pandas as pd


def clean_dict_column(
    df: pd.DataFrame,
    column: str,
    key: str,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, cleaning the string column
    formatted as dict, getting the value of the provided key.

    Args:
        df (pd.DataFrame): the original DataFrame
        column (str): the column name
        key (str): the key from where to get the return value

    Returns:
        pd.DataFrame: the cleaned DataFrame

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column] = local_df[column].apply(
        lambda s: json.dumps(eval(s)[key], ensure_ascii=False))

    return local_df


def clean_stringified_list(
    list_as_string: str,
    return_if_empty: Any = &#39;[]&#39;,
) -&gt; str:
    &#39;&#39;&#39;Creates a copy of the provided stringified list, where the elements are
    the original ones if they are not lists and the elements inside the elements
    if the elements itself are lists. It also remove elements that are empty
    strings.

    Args:
        list_as_string (str): the stringified list to clean
        return_if_empty (Any, optional): the value to return in case the list is
            empty. Defaults to a stringified empty list.

    Returns:
        Any: the cleaned copy of the original string or the specified value in
            case it generates an empty list

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    list_as_list = eval(list_as_string)
    temp_set = set()

    for value in list_as_list:
        if isinstance(value, list):
            for inner_value in value:
                temp_set.add(inner_value)
        else:
            temp_set.add(value)

    sorted_list = sorted([v for v in temp_set if v])
    if sorted_list:
        sorted_string = json.dumps(sorted_list, ensure_ascii=False)
    else:
        sorted_string = return_if_empty
    return sorted_string


def clean_braces(df: pd.DataFrame, column: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, cleaning the stringified column
    provided, where the final string representation is a cleaned list, without
    inner lists or empty strings.

    Args:
        df (pd.DataFrame): the original DataFrame
        column (str): the name of the column to be cleaned

    Returns:
        pd.DataFrame: the cleaned DataFrame

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column] = local_df[column].apply(
        lambda s: clean_stringified_list(
            s.strip().replace(&#39;{&#39;, &#39;[&#39;).replace(&#39;}&#39;, &#39;]&#39;)
        )
    )

    return local_df


def make_a_clean_stringified_list(string: str) -&gt; str:
    &#39;&#39;&#39;Clean a list-like string if it is indeed list-like, and if it is a simple
    string return a list-like string with this initial string as its item. The
    returned &#34;list&#34; has only unique values.

    If the provided value is nan, return nan.

    Args:
        string (str): the string to clean

    Raises:
        ValueError: if the provided &#34;string&#34; is not of type string nor pd.NA

    Returns:
        str: the cleaned list-like string.

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    # This meas that the original string is not a list-like string
    try:
        if not string.startswith(&#39;[&#39;):
            # an it should be
            string = json.dumps([string], ensure_ascii=False)
    except AttributeError:
        if pd.isna(string):
            return string
        else:
            raise ValueError(&#39;The provided &#34;string&#34; argument is not a string.&#39;)

    string = clean_stringified_list(string)

    return string


def remove_duplicated_values(
    df: pd.DataFrame,
    list_like_columns: list[str],
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, turning the values in each list
    like columns unique

    Args:
        df (pd.DataFrame): the original DataFrame
        list_like_columns (list[str]): the columns names to apply to cleaning

    Returns:
        pd.DataFrame: the DataFrame with the unique values

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    local_df = df.copy()

    for col in list_like_columns:
        local_df[col] = local_df[col].apply(make_a_clean_stringified_list)

    return local_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sbees.insecure.clean_braces"><code class="name flex">
<span>def <span class="ident">clean_braces</span></span>(<span>df: pandas.core.frame.DataFrame, column: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the provided DataFrame, cleaning the stringified column
provided, where the final string representation is a cleaned list, without
inner lists or empty strings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the original DataFrame</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the column to be cleaned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the cleaned DataFrame</dd>
</dl>
<p>DISCLAIMER: This is considered a not secure method because it uses the
eval() method, that tries to turn any string into Python code, which is
clearly an insecure operation. It is not recommended to use this method in a
non-trusted dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_braces(df: pd.DataFrame, column: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, cleaning the stringified column
    provided, where the final string representation is a cleaned list, without
    inner lists or empty strings.

    Args:
        df (pd.DataFrame): the original DataFrame
        column (str): the name of the column to be cleaned

    Returns:
        pd.DataFrame: the cleaned DataFrame

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column] = local_df[column].apply(
        lambda s: clean_stringified_list(
            s.strip().replace(&#39;{&#39;, &#39;[&#39;).replace(&#39;}&#39;, &#39;]&#39;)
        )
    )

    return local_df</code></pre>
</details>
</dd>
<dt id="sbees.insecure.clean_dict_column"><code class="name flex">
<span>def <span class="ident">clean_dict_column</span></span>(<span>df: pandas.core.frame.DataFrame, column: str, key: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the provided DataFrame, cleaning the string column
formatted as dict, getting the value of the provided key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the original DataFrame</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>the column name</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>the key from where to get the return value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the cleaned DataFrame</dd>
</dl>
<p>DISCLAIMER: This is considered a not secure method because it uses the
eval() method, that tries to turn any string into Python code, which is
clearly an insecure operation. It is not recommended to use this method in a
non-trusted dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_dict_column(
    df: pd.DataFrame,
    column: str,
    key: str,
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, cleaning the string column
    formatted as dict, getting the value of the provided key.

    Args:
        df (pd.DataFrame): the original DataFrame
        column (str): the column name
        key (str): the key from where to get the return value

    Returns:
        pd.DataFrame: the cleaned DataFrame

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    local_df = df.copy()

    local_df[column] = local_df[column].apply(
        lambda s: json.dumps(eval(s)[key], ensure_ascii=False))

    return local_df</code></pre>
</details>
</dd>
<dt id="sbees.insecure.clean_stringified_list"><code class="name flex">
<span>def <span class="ident">clean_stringified_list</span></span>(<span>list_as_string: str, return_if_empty: Any = '[]') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the provided stringified list, where the elements are
the original ones if they are not lists and the elements inside the elements
if the elements itself are lists. It also remove elements that are empty
strings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_as_string</code></strong> :&ensp;<code>str</code></dt>
<dd>the stringified list to clean</dd>
<dt><strong><code>return_if_empty</code></strong> :&ensp;<code>Any</code>, optional</dt>
<dd>the value to return in case the list is
empty. Defaults to a stringified empty list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>the cleaned copy of the original string or the specified value in
case it generates an empty list</dd>
</dl>
<p>DISCLAIMER: This is considered a not secure method because it uses the
eval() method, that tries to turn any string into Python code, which is
clearly an insecure operation. It is not recommended to use this method in a
non-trusted dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_stringified_list(
    list_as_string: str,
    return_if_empty: Any = &#39;[]&#39;,
) -&gt; str:
    &#39;&#39;&#39;Creates a copy of the provided stringified list, where the elements are
    the original ones if they are not lists and the elements inside the elements
    if the elements itself are lists. It also remove elements that are empty
    strings.

    Args:
        list_as_string (str): the stringified list to clean
        return_if_empty (Any, optional): the value to return in case the list is
            empty. Defaults to a stringified empty list.

    Returns:
        Any: the cleaned copy of the original string or the specified value in
            case it generates an empty list

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    list_as_list = eval(list_as_string)
    temp_set = set()

    for value in list_as_list:
        if isinstance(value, list):
            for inner_value in value:
                temp_set.add(inner_value)
        else:
            temp_set.add(value)

    sorted_list = sorted([v for v in temp_set if v])
    if sorted_list:
        sorted_string = json.dumps(sorted_list, ensure_ascii=False)
    else:
        sorted_string = return_if_empty
    return sorted_string</code></pre>
</details>
</dd>
<dt id="sbees.insecure.make_a_clean_stringified_list"><code class="name flex">
<span>def <span class="ident">make_a_clean_stringified_list</span></span>(<span>string: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Clean a list-like string if it is indeed list-like, and if it is a simple
string return a list-like string with this initial string as its item. The
returned "list" has only unique values.</p>
<p>If the provided value is nan, return nan.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>the string to clean</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if the provided "string" is not of type string nor pd.NA</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the cleaned list-like string.</dd>
</dl>
<p>DISCLAIMER: This is considered a not secure method because it uses the
eval() method, that tries to turn any string into Python code, which is
clearly an insecure operation. It is not recommended to use this method in a
non-trusted dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_a_clean_stringified_list(string: str) -&gt; str:
    &#39;&#39;&#39;Clean a list-like string if it is indeed list-like, and if it is a simple
    string return a list-like string with this initial string as its item. The
    returned &#34;list&#34; has only unique values.

    If the provided value is nan, return nan.

    Args:
        string (str): the string to clean

    Raises:
        ValueError: if the provided &#34;string&#34; is not of type string nor pd.NA

    Returns:
        str: the cleaned list-like string.

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    # This meas that the original string is not a list-like string
    try:
        if not string.startswith(&#39;[&#39;):
            # an it should be
            string = json.dumps([string], ensure_ascii=False)
    except AttributeError:
        if pd.isna(string):
            return string
        else:
            raise ValueError(&#39;The provided &#34;string&#34; argument is not a string.&#39;)

    string = clean_stringified_list(string)

    return string</code></pre>
</details>
</dd>
<dt id="sbees.insecure.remove_duplicated_values"><code class="name flex">
<span>def <span class="ident">remove_duplicated_values</span></span>(<span>df: pandas.core.frame.DataFrame, list_like_columns: list) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a copy of the provided DataFrame, turning the values in each list
like columns unique</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>the original DataFrame</dd>
<dt><strong><code>list_like_columns</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>the columns names to apply to cleaning</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the DataFrame with the unique values</dd>
</dl>
<p>DISCLAIMER: This is considered a not secure method because it uses the
eval() method, that tries to turn any string into Python code, which is
clearly an insecure operation. It is not recommended to use this method in a
non-trusted dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_duplicated_values(
    df: pd.DataFrame,
    list_like_columns: list[str],
) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Creates a copy of the provided DataFrame, turning the values in each list
    like columns unique

    Args:
        df (pd.DataFrame): the original DataFrame
        list_like_columns (list[str]): the columns names to apply to cleaning

    Returns:
        pd.DataFrame: the DataFrame with the unique values

    DISCLAIMER: This is considered a not secure method because it uses the
    eval() method, that tries to turn any string into Python code, which is
    clearly an insecure operation. It is not recommended to use this method in a
    non-trusted dataset.
    &#39;&#39;&#39;

    local_df = df.copy()

    for col in list_like_columns:
        local_df[col] = local_df[col].apply(make_a_clean_stringified_list)

    return local_df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sbees" href="index.html">sbees</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sbees.insecure.clean_braces" href="#sbees.insecure.clean_braces">clean_braces</a></code></li>
<li><code><a title="sbees.insecure.clean_dict_column" href="#sbees.insecure.clean_dict_column">clean_dict_column</a></code></li>
<li><code><a title="sbees.insecure.clean_stringified_list" href="#sbees.insecure.clean_stringified_list">clean_stringified_list</a></code></li>
<li><code><a title="sbees.insecure.make_a_clean_stringified_list" href="#sbees.insecure.make_a_clean_stringified_list">make_a_clean_stringified_list</a></code></li>
<li><code><a title="sbees.insecure.remove_duplicated_values" href="#sbees.insecure.remove_duplicated_values">remove_duplicated_values</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>